module bimode(
    input clk,
    input rst,
    input [63:0] branch_address,     //64 bits branch address.
    input real_ton,
    output reg prediction
);
    //variables internas.
    reg [7:0] global_history;      //8 bits history. Shift register.
    wire [7:0] index;             //index generated by xor
    wire [7:0] index2; 
    integer i;
    reg aciertos, total;
    real porcentaje_de_aciertos;

    //Tablas PTH
    reg [1:0] selection_pht [0:255];         //PHT 2 bits (2bc), and 64 bits lenght (global_history bits)^2 
    reg [1:0] taken_pht [0:255];  
    reg [1:0] not_taken_pht [0:255];  

    //XOR para index.
    assign index = global_history ^ branch_address[7:0]; // index para taken y no_taken pht
    //index de seleccion solo depende de branch address
    assign index2 = branch_address[7:0]; // index para selection_pht
    
    always@(posedge clk or posedge rst) begin
        if(rst)begin
            for (i = 0; i < 255; i = i + 1) begin 
                taken_pht[i] <= 2'b01;      // estado inicial "neutro" = weak not taken
                not_taken_pht[i] <= 2'b01;  // estado inicial "neutro" = weak not taken
                selection_pht[i] <= 2'b01;  // estado inicial "neutro" = weak not taken
                aciertos = 0;
                total=0;
            end
            global_history <= 8'b0; // y el historial esta en NT por default.
        end


        else begin
            //eleccion
            if(selection_pht[index2] > 2'b01)begin //si taken_pht es wt o st se va a taken_pht
                if(taken_pht[index]>2'b01)begin  //si taken_pht decide que se tome, porque es weak take o st
                    prediction = 1'b1;    //take
                end
                else begin
                    prediction = 1'b0;       //si la tabla taken_pht decide que no se toma
                end
            end

            else begin  // sino, se va a la tabla de not_taken y ve que decide not_taken
                if(not_taken_pht[index]>2'b01)begin  //si not_taken_pht decide que se tome, porque es weak take o st
                    prediction = 1'b0;       //not take
                end
                else begin
                    prediction = 1'b1;       //si la tabla no_taken_pht decide que no se toma
                end
            end


            //cambios a partir del resultado real.
            // Actualización predicción.
            if (real_ton == prediction) begin // Predicción correcta. Aumentar confianza (saturadamente)
                aciertos=aciertos+1;
                total = total+1;
                if (selection_pht[index2] != 2'b11) begin
                    selection_pht[index2] <= selection_pht[index2] + 1; // Incrementar si no está saturado.
                end
                if(taken_pht[index] != 2'b11) //contador saturado
                    taken_pht[index] <= taken_pht[index]+1;
            end
            else begin
                // Predicción incorrecta.
                total=total+1;
                if (selection_pht[index2] != 2'b00) begin
                    selection_pht[index2] <= selection_pht[index2] - 1; // Decrementar si no está saturado.
                end
                if(not_taken_pht[index] != 2'b11) //contador saturado
                    not_taken_pht[index] <= not_taken_pht[index]+1;
            end

            
            //porcentaje de aciertos
            if (total > 0) begin
                porcentaje_de_aciertos <= (aciertos / total) * 100.0;
            end else begin
                porcentaje_de_aciertos <= 0.0; // Prevenir división por cero.
            end

            //actualizacion de la historia global shift(FIFO)
            global_history <= {global_history[6:0], real_ton};

            //BTB
            



        end
    end

endmodule 








